import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:senior_project/news_section/widgets/appBar.dart';
import 'package:senior_project/vulnerability_section/vulnerability_service.dart';
import 'package:url_launcher/url_launcher.dart';

class VulnerabilityPage extends StatefulWidget {
  @override
  _VulnerabilityPageState createState() => _VulnerabilityPageState();
}

class _VulnerabilityPageState extends State<VulnerabilityPage> {
  final VulnerabilityService _service = VulnerabilityService();
  late Future<List<dynamic>> _vulnerabilityList;
  String _searchKeyword = '';

  bool isLoggedIn = false;

  @override
  void initState() {
    super.initState();
    _checkUserLogin();
    _vulnerabilityList = _service.fetchVulnerabilities();
  }

  FirebaseAuth auth = FirebaseAuth.instance;

  Future<void> _checkUserLogin() async {
    if (auth.currentUser != null) {
      isLoggedIn = true;
    }
  }

  void _launchSearch(String vulnerabilityName) async {
    // Constructing a more detailed Google search URL
    String query = Uri.encodeComponent('$vulnerabilityName');
    String googleSearchUrl = 'https://nvd.nist.gov/vuln/detail/$query';

    if (await canLaunch(googleSearchUrl)) {
      await launch(googleSearchUrl);
    } else {
      print('Could not launch $googleSearchUrl');
    }
  }

  void _filterVulnerabilities(String keyword) {
    setState(() {
      _searchKeyword = keyword.toLowerCase();
    });
  }

  bool _vulnerabilityMatchesSearch(dynamic vulnerability) {
    // Adjust the field to match against based on your data structure
    String description =
        vulnerability['cve']['descriptions'][0]['value'].toLowerCase();
    return description.contains(_searchKeyword);
  }

  // Function to save the vulnerability for authenticated users
  void _saveVulnerability(String vulnerabilityId) async {
    // Check if the user is signed in
    User? user = FirebaseAuth.instance.currentUser;

    if (user != null) {
      // User is signed in, save the vulnerability URL to Firestore
      try {
        String userId = user.uid;
        String vulnerabilityUrl =
            'https://nvd.nist.gov/vuln/detail/$vulnerabilityId';

        DocumentReference userRef =
            FirebaseFirestore.instance.collection('User').doc(userId);

        // Get the current user's favURLs
        List<String> currentFavURLs = [];

        DocumentSnapshot userSnapshot = await userRef.get();
        if (userSnapshot.exists && userSnapshot.data() != null) {
          var userData = userSnapshot.data() as Map<String, dynamic>;
          currentFavURLs = List<String>.from(userData['favURLs'] ?? []);
        }

        if (currentFavURLs.contains(vulnerabilityUrl)) {
          // Remove from favorites
          currentFavURLs.remove(vulnerabilityUrl);
        } else {
          // Add to favorites
          currentFavURLs.add(vulnerabilityUrl);
        }

        // Update the user's document with the new favURLs
        await userRef.update({'favURLs': currentFavURLs});

        print('Vulnerability saved for user: $userId');
      } catch (error) {
        print('Error saving vulnerability: $error');
      }
    } else {
      // User is not signed in, show a message or handle accordingly
      print('User is not signed in');
    }
  }

  // Function to build the save button/icon
  Widget? _buildSaveButton(String vulnerabilityId) {
    // Check if the user is signed in
    User? user = FirebaseAuth.instance.currentUser;

    if (user != null) {
      // User is signed in, show the save button/icon
      return IconButton(
        icon: Icon(Icons.save),
        onPressed: () => _saveVulnerability(vulnerabilityId),
      );
    } else {
      // User is not signed in, return null
      return null;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: SectionAppBar(currentSection: 'Vulnerabilities'),
      body: Column(
        children: [
          Padding(
            padding: EdgeInsets.all(8.0),
            child: TextField(
              onChanged: (value) => _filterVulnerabilities(value),
              decoration: InputDecoration(
                labelText: 'Search Vulnerabilities',
                border: OutlineInputBorder(),
                suffixIcon: Icon(Icons.search),
              ),
            ),
          ),
          Expanded(
            child: FutureBuilder<List<dynamic>>(
              future: _vulnerabilityList,
              builder: (context, snapshot) {
                if (snapshot.connectionState == ConnectionState.waiting) {
                  return Center(child: CircularProgressIndicator());
                } else if (snapshot.hasError || snapshot.data == null) {
                  return Center(child: Text('Error occurred'));
                } else {
                  var vulnerabilities = snapshot.data!
                      .where(_vulnerabilityMatchesSearch)
                      .toList();

                  return ListView.builder(
                    itemCount: vulnerabilities.length,
                    itemBuilder: (context, index) {
                      var vulnerability = vulnerabilities[index];
                      return ListTile(
                        title: Text(vulnerability['cve']['id']),
                        subtitle: Text(
                            vulnerability['cve']['descriptions'][0]['value']),
                        onTap: () => _launchSearch(vulnerability['cve']['id']),
                        // Add save button/icon for authenticated users
                        trailing: _buildSaveButton(vulnerability['cve']['id']),
                      );
                    },
                  );
                }
              },
            ),
          ),
        ],
      ),
    );
  }
}
